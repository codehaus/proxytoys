/*
 * Created on 11-May-2004
 *
 * (c) 2003-2005 ThoughtWorks Ltd
 *
 * See license.txt for license details
 */
package com.thoughtworks.proxy.toys.multicast;

import com.thoughtworks.proxy.Invoker;
import com.thoughtworks.proxy.ProxyFactory;
import com.thoughtworks.proxy.kit.ReflectionUtils;

import java.lang.reflect.Array;
import java.lang.reflect.Method;
import java.util.ArrayList;
import java.util.List;


/**
 * A {@link Invoker} implementation that multicasts calls to multiple targets. Proxies generated by this class will
 * forward all method invocations to an array of underlying objects. The behaviour is recursive, so return values will
 * also be multicasting objects.
 *
 * @author Aslak Helles&oslash;y
 * @author Chris Stevenson
 * @author J&ouml;rg Schaible
 */
public class MulticastingInvoker implements Invoker {
    private static final long serialVersionUID = 1L;
    private static final Method multicastTargetsDirect;
    private static final Method multicastTargetsIndirect;
    private static final Method getTargetsInArray;
    private static final Method getTargetsInTypedArray;

    static {
        try {
            multicastTargetsDirect = Multicast.class.getMethod("multicastTargets", new Class[]{
                    Method.class, Object[].class});
            multicastTargetsIndirect = Multicast.class.getMethod("multicastTargets", new Class[]{
                    Class.class, String.class, Object[].class});
            getTargetsInArray = Multicast.class.getMethod("getTargetsInArray");
            getTargetsInTypedArray = Multicast.class.getMethod("getTargetsInArray", new Class[]{Class.class});
        } catch (NoSuchMethodException e) {
            // /CLOVER:OFF
            throw new InternalError();
            // /CLOVER:ON
        } catch (SecurityException e) {
            // /CLOVER:OFF
            throw new InternalError();
            // /CLOVER:ON
        }
    }

    private Class[] types;
    private ProxyFactory proxyFactory;
    private Object[] targets;

    /**
     * Construct a MulticastingInvoker.
     *
     * @param type         the implemented types
     * @param proxyFactory the {@link ProxyFactory} to use
     * @param targets      the target instances where the proxy delegates a call

     */
    public MulticastingInvoker(final Class[] type, final ProxyFactory proxyFactory, final Object[] targets) {
        this.types = type;
        this.proxyFactory = proxyFactory;
        this.targets = targets;
    }

    /**
     * Create a proxy for this Invoker.
     *
     * @return the new proxy

     */
    public Object proxy() {
        final Class[] classes;
        int i;
        i = types.length;
        while (--i >= 0 && types[i] != Multicast.class) {
        }
        if (i < 0) {
            classes = new Class[types.length + 1];
            if (classes.length > 1) {
                System.arraycopy(types, 0, classes, 1, types.length);
            }
            classes[0] = Multicast.class;
        } else {
            classes = types;
        }
        return proxyFactory.createProxy(this, classes);
    }

    public Object invoke(final Object proxy, Method method, Object[] args) throws Throwable {
        if (getTargetsInArray.equals(method)) {
            return targets;
        } else if (getTargetsInTypedArray.equals(method)) {
            final Object[] elements = (Object[]) Array.newInstance((Class) args[0], targets.length);
            System.arraycopy(targets, 0, elements, 0, targets.length);
            return elements;
        } else if (multicastTargetsDirect.equals(method)) {
            method = (Method) args[0];
            args = (Object[]) args[1];
        } else if (multicastTargetsIndirect.equals(method)) {
            final Object[] newArgs = args[2] == null ? new Object[0] : (Object[]) args[2];
            method = ReflectionUtils.getMatchingMethod((Class) args[0], (String) args[1], newArgs);
            args = newArgs;
        }
        final List<Object> invocationResults = new ArrayList<Object>();
        for (Object target : targets) {
            if (method.getDeclaringClass().isInstance(target)) {
                Object result = method.invoke(target, args);
                if (result != null) {
                    invocationResults.add(result);
                }
            }
        }
        if (invocationResults.size() == 0) {
            return null;
        } else if (invocationResults.size() == 1) {
            return invocationResults.get(0);
        } else if (method.getReturnType().equals(byte.class)) {
            return addBytes(invocationResults.toArray());
        } else if (method.getReturnType().equals(char.class)) {
            return addChars(invocationResults.toArray());
        } else if (method.getReturnType().equals(short.class)) {
            return addShorts(invocationResults.toArray());
        } else if (method.getReturnType().equals(int.class)) {
            return addIntegers(invocationResults.toArray());
        } else if (method.getReturnType().equals(long.class)) {
            return addLongs(invocationResults.toArray());
        } else if (method.getReturnType().equals(float.class)) {
            return addFloats(invocationResults.toArray());
        } else if (method.getReturnType().equals(double.class)) {
            return addDoubles(invocationResults.toArray());
        } else if (method.getReturnType().equals(boolean.class)) {
            return andBooleans(invocationResults.toArray());
        } else {
            return Multicasting.multicastable(invocationResults.toArray()).build(proxyFactory);
        }
    }

    private static Byte addBytes(final Object[] args) {
        byte result = 0;
        for (Object arg : args) {
            result += (Byte) arg;
        }
        return result;
    }

    private static Character addChars(final Object[] args) {
        char result = 0;
        for (Object arg : args) {
            result += (Character) arg;
        }
        return result;
    }

    private static Short addShorts(final Object[] args) {
        short result = 0;
        for (Object arg : args) {
            result += (Short) arg;
        }
        return result;
    }

    private static Integer addIntegers(final Object[] args) {
        int result = 0;
        for (Object arg : args) {
            result += (Integer) arg;
        }
        return result;
    }

    private static Long addLongs(final Object[] args) {
        long result = 0;
        for (Object arg : args) {
            result += (Long) arg;
        }
        return result;
    }

    private static Float addFloats(final Object[] args) {
        float result = 0;
        for (Object arg : args) {
            result += (Float) arg;
        }
        return result;
    }

    private static Double addDoubles(final Object[] args) {
        double result = 0;
        for (Object arg : args) {
            result += (Double) arg;
        }
        return result;
    }

    private static Boolean andBooleans(final Object[] args) {
        for (Object arg : args) {
            if (!(Boolean) arg) {
                return Boolean.FALSE;
            }
        }
        return Boolean.TRUE;
    }
}